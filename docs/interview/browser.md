---
outline: deep
---
## V8 引擎的原理和编译、执行 JS 的具体步骤

::: details
V8 引擎是 Google 开发的开源 JavaScript 引擎，主要用于 Chrome 浏览器和 Node.js。它通过将 JavaScript 代码编译为机器码来提高执行速度，并使用即时编译（JIT）技术来优化性能。以下是 V8 引擎的工作原理以及编译和执行 JavaScript 的具体步骤：

### V8 引擎的原理

1. **解析**:
   - V8 首先将 JavaScript 源代码解析为抽象语法树（AST）。解析过程包括词法分析和语法分析。
   - 词法分析将源代码分解为标记（tokens），而语法分析则根据语言的语法规则构建 AST。

2. **编译**:
   - V8 使用两种编译器：一个是解释器（Ignition），另一个是优化编译器（TurboFan）。
   - **解释器**: Ignition 将 AST 转换为字节码，字节码是一种中间表示形式，便于快速执行。
   - **优化编译器**: 当某段代码被频繁执行时，TurboFan 会对其进行优化，将字节码编译为高效的机器码，以提高执行速度。

3. **执行**:
   - V8 执行字节码或机器码。执行过程中，V8 会管理内存和变量的作用域，处理函数调用和返回等操作。

4. **垃圾回收**:
   - V8 使用垃圾回收机制来自动管理内存，定期清理不再使用的对象，减少内存泄漏的风险。

### 编译和执行 JS 的具体步骤

1. **加载 JavaScript 文件**:
   - V8 加载 JavaScript 源代码文件。

2. **解析源代码**:
   - V8 进行词法分析和语法分析，生成 AST。

3. **生成字节码**:
   - V8 将 AST 转换为字节码，准备执行。

4. **执行字节码**:
   - V8 通过解释器 Ignition 执行字节码，逐行执行代码。

5. **监测热点代码**:
   - V8 监测执行频率，识别热点代码（即频繁执行的代码段）。

6. **优化编译**:
   - 对热点代码进行优化，使用 TurboFan 将字节码编译为机器码。

7. **执行机器码**:
   - V8 执行优化后的机器码，提供更高的执行效率。

8. **垃圾回收**:
   - V8 定期进行垃圾回收，清理不再使用的对象，释放内存。

:::

## 也没有了解过热点代码

:::details
热点代码是指在程序执行过程中频繁被调用的代码段。V8引擎会优先优化这些代码，以提高整体性能。

- 热点代码通常是性能瓶颈，优化这些代码可以显著提高应用的响应速度。
- V8引擎会监测代码的执行频率，并对热点代码进行优化处理。
- 通过即时编译，V8能够在运行时对热点代码进行优化，提升执行效率。

:::

## WebKit、JSCore 与渲染引擎原理

::: details

- WebKit
  - **定义**: WebKit 是一个开源的网页浏览器引擎，最初由苹果公司开发，广泛用于 Safari 浏览器和 iOS 的 WebView 组件。
  - **组成**: WebKit 包含多个组件，其中最重要的是渲染引擎（负责将 HTML、CSS 和 JavaScript 转换为可视化的网页）和 JavaScript 引擎（负责执行 JavaScript 代码）。
  - **功能**:
    - 解析 HTML 和 CSS，构建 DOM（文档对象模型）和 CSSOM（CSS 对象模型）。
    - 处理 JavaScript 代码的执行，更新 DOM 和 CSSOM。
    - 渲染页面并处理用户交互。

- JSCore
  - **定义**: JSCore 是 WebKit 中的 JavaScript 引擎，负责执行 JavaScript 代码。
  - **功能**:
    - 解析和编译 JavaScript 代码，将其转换为可执行的机器代码。
    - 提供执行上下文，管理变量作用域和闭包。
    - 处理事件循环和异步操作，确保 JavaScript 代码的非阻塞执行。
  - **优化**: JSCore 采用了多种优化技术，如即时编译（JIT）和垃圾回收，以提高执行效率和内存管理。

- 渲染引擎原理
  - **工作流程**:
    1. **解析**: 渲染引擎首先解析 HTML 文档，构建 DOM 树。然后解析 CSS，构建 CSSOM。
    2. **渲染树**: 将 DOM 和 CSSOM 合并，生成渲染树，表示页面的可视化结构。
    3. **布局**: 计算每个节点的几何信息（位置和大小），确定如何在屏幕上呈现。
    4. **绘制**: 将渲染树中的节点绘制到屏幕上，生成最终的视觉效果。
    5. **重绘和重排**: 当 DOM 或 CSSOM 发生变化时，渲染引擎会进行重绘（更新视觉效果）和重排（重新计算布局）。

- WebKit 是一个综合性的浏览器引擎，包含 JSCore 作为其 JavaScript 执行引擎。渲染引擎负责将网页内容解析、布局和绘制到屏幕上。理解这些组件的工作原理有助于开发高效的 Web 应用和优化用户体验。
:::

## 浏览器的架构

::: details
浏览器的架构通常可以分为多个主要组件，每个组件负责不同的功能。以下是浏览器架构的主要组成部分：

1. **用户界面**:
   - 用户界面是用户与浏览器交互的部分，包括地址栏、书签、菜单、标签页等。用户通过这些界面元素输入 URL、导航网页和管理书签。

2. **浏览器引擎**:
   - 浏览器引擎负责将用户的请求传递给渲染引擎，并处理渲染引擎返回的内容。它充当用户界面和渲染引擎之间的桥梁。

3. **渲染引擎**:
   - 渲染引擎负责解析 HTML、CSS 和 JavaScript，构建 DOM 树和 CSSOM 树，生成渲染树，并进行布局和绘制。常见的渲染引擎包括 WebKit（Safari）、Blink（Chrome）和 Gecko（Firefox）。

4. **JavaScript 引擎**:
   - JavaScript 引擎负责执行 JavaScript 代码。它将 JavaScript 代码解析并编译为机器码，以提高执行速度。常见的 JavaScript 引擎包括 V8（Chrome 和 Node.js）、SpiderMonkey（Firefox）和 JavaScriptCore（Safari）。

5. **网络模块**:
   - 网络模块负责处理网络请求和响应，包括 DNS 解析、TCP 连接、HTTP 请求和响应等。它管理与服务器的通信，确保数据的传输。

6. **数据存储**:
   - 数据存储模块负责管理浏览器的本地存储，包括 cookies、localStorage、sessionStorage 和 IndexedDB。它允许网页在用户的设备上存储数据，以便在后续访问中使用。

7. **安全模块**:
   - 安全模块负责处理浏览器的安全性，包括跨域限制、内容安全策略（CSP）、HTTPS 加密等。它确保用户的数据和隐私得到保护，防止恶意攻击。

8. **插件和扩展**:
   - 浏览器支持插件和扩展，允许用户自定义浏览器的功能和外观。插件和扩展可以增强浏览器的功能，如广告拦截、密码管理等。

- 浏览器的架构由多个组件组成，包括用户界面、浏览器引擎、渲染引擎、JavaScript 引擎、网络模块、数据存储、安全模块以及插件和扩展。每个组件在浏览器的整体功能中扮演着重要角色，协同工作以提供良好的用户体验。
:::

## 浏览器进程都有哪些，各个特点是什么

::: details
浏览器通常会使用多进程架构来提高性能和安全性。以下是浏览器进程的主要类型及其特点：

1. **主进程**:
   - **特点**:
     - 主进程是浏览器的核心进程，负责管理用户界面、浏览器窗口、标签页和其他全局功能。
     - 处理用户输入、菜单、地址栏、书签等操作。
     - 负责与渲染进程、网络进程和其他子进程的通信。

2. **渲染进程**:
   - **特点**:
     - 每个标签页通常会有一个独立的渲染进程，负责解析 HTML、CSS 和 JavaScript，构建 DOM 和 CSSOM，生成渲染树，并进行布局和绘制。
     - 渲染进程是相互隔离的，确保一个标签页的崩溃不会影响其他标签页的运行。
     - 处理页面的 JavaScript 执行和事件处理。

3. **网络进程**:
   - **特点**:
     - 网络进程负责处理所有的网络请求，包括 DNS 解析、HTTP 请求和响应等。
     - 负责管理与服务器的通信，确保数据的传输。
     - 通过将网络操作与渲染进程分离，提高了安全性和性能。

4. **GPU 进程**:
   - **特点**:
     - GPU 进程负责处理图形渲染和加速，特别是在处理复杂的动画和视觉效果时。
     - 将图形处理任务从主进程和渲染进程中分离，减轻 CPU 的负担，提高渲染性能。
     - 通过使用 GPU 加速，提升页面的流畅度和响应速度。

5. **扩展进程**:
   - **特点**:
     - 每个浏览器扩展通常会在独立的进程中运行，以确保扩展的安全性和稳定性。
     - 扩展进程与主进程和渲染进程之间进行通信，允许扩展访问浏览器的功能和数据。

- 浏览器的多进程架构包括主进程、渲染进程、网络进程、GPU 进程和扩展进程。每个进程负责不同的功能，确保浏览器的性能、安全性和稳定性。通过将不同的任务分配给独立的进程，浏览器能够更好地管理资源，提高用户体验。
:::

## 聊一下浏览器事件循环与队列

::: details

:::

## 用户从输入 URL 到页面加载完毕都经历了哪些步骤？

::: details
用户从输入 URL 到页面加载完毕的过程涉及多个步骤，主要包括以下几个阶段：

1. **URL 输入**:
   - 用户在浏览器的地址栏中输入 URL，并按下回车键。

2. **DNS 解析**:
   - 浏览器向 DNS（域名系统）服务器发送请求，将域名解析为对应的 IP 地址。这个过程可能涉及多个 DNS 服务器的查询。

3. **建立 TCP 连接**:
   - 一旦获得 IP 地址，浏览器与目标服务器建立 TCP 连接。对于 HTTPS 请求，还会进行 TLS 握手以建立安全连接。

4. **发送 HTTP 请求**:
   - TCP 连接建立后，浏览器向服务器发送 HTTP 请求，请求特定的资源（如 HTML 页面、图片、CSS 文件等）。

5. **服务器处理请求**:
   - 服务器接收到请求后，处理请求并生成响应。这个过程可能涉及数据库查询、业务逻辑处理等。

6. **返回 HTTP 响应**:
   - 服务器将处理结果（如 HTML 文档）作为 HTTP 响应返回给浏览器。

7. **浏览器接收响应**:
   - 浏览器接收到服务器的响应后，开始解析和处理响应内容。

8. **解析 HTML**:
   - 浏览器解析 HTML 文档，构建 DOM（文档对象模型）树。

9. **解析 CSS**:
   - 浏览器解析 CSS 文件，构建 CSSOM（CSS 对象模型）树。

10. **构建渲染树**:
    - 将 DOM 和 CSSOM 合并，生成渲染树，表示页面的可视化结构。

11. **布局计算**:
    - 计算每个节点的几何信息（位置和大小），确定如何在屏幕上呈现。

12. **绘制**:
    - 将渲染树中的节点绘制到屏幕上，生成最终的视觉效果。

13. **执行 JavaScript**:
    - 如果页面中包含 JavaScript，浏览器会执行这些脚本，可能会修改 DOM 或 CSSOM，导致重绘或重排。

14. **页面加载完毕**:
    - 当所有资源（如图片、样式表、脚本等）都加载完成，浏览器会触发 `load` 事件，表示页面加载完毕。

- 用户从输入 URL 到页面加载完毕的过程涉及 DNS 解析、TCP 连接建立、HTTP 请求和响应、HTML 和 CSS 解析、渲染树构建、布局计算、绘制以及 JavaScript 执行等多个步骤。
:::

## 浏览器渲染页面 Layout 分为几层，各个特点是什么？

::: details
浏览器渲染页面的过程通常可以分为以下几个主要层次，每一层都有其独特的特点和功能：

1. **HTML 解析层**:
   - **特点**:
     - 浏览器首先解析 HTML 文档，构建 DOM（文档对象模型）树。
     - DOM 树是一个表示文档结构的树形结构，节点对应于 HTML 元素。
     - 解析过程中，浏览器会处理标签、属性和文本内容。

2. **CSS 解析层**:
   - **特点**:
     - 浏览器解析 CSS 文件，构建 CSSOM（CSS 对象模型）树。
     - CSSOM 树表示样式信息，节点对应于 CSS 规则。
     - 解析过程中，浏览器会处理选择器、属性和样式值。

3. **渲染树构建层**:
   - **特点**:
     - 将 DOM 树和 CSSOM 树合并，生成渲染树。
     - 渲染树只包含可见的元素，排除那些 `display: none` 的元素。
     - 每个节点包含了元素的样式信息，准备进行布局计算。

4. **布局层 (Layout)**:
   - **特点**:
     - 计算每个节点的几何信息（位置和大小），确定如何在屏幕上呈现。
     - 这个过程也称为“重排”（Reflow），涉及到元素的尺寸、位置和相对关系。
     - 布局计算是一个重要的性能开销，尤其是在页面结构复杂时。

5. **绘制层 (Painting)**:
   - **特点**:
     - 将渲染树中的节点绘制到屏幕上，生成最终的视觉效果。
     - 这个过程涉及到颜色、文本、图像等的绘制。
     - 绘制操作通常是分层进行的，浏览器会将不同的层合成最终的图像。

6. **合成层 (Compositing)**:
   - **特点**:
     - 在现代浏览器中，绘制的内容可能会被分成多个层（如动画、视频等）。
     - 合成层负责将这些层合并成最终的图像，提升性能和流畅度。
     - 合成可以在 GPU 上进行，减少 CPU 的负担，提高渲染效率。

- 浏览器渲染页面的过程分为多个层次，包括 HTML 解析层、CSS 解析层、渲染树构建层、布局层、绘制层和合成层。每一层都有其独特的功能和特点，理解这些层次有助于优化网页性能和用户体验。
:::

## 页面布局中哪些操作会脱离文档流？

::: details
在网页布局中，某些 CSS 属性和操作会导致元素脱离文档流，从而影响其他元素的布局。以下是一些常见的会导致元素脱离文档流的操作：

1. **使用 `position` 属性**:
   - **绝对定位 (`position: absolute`)**:
     - 元素相对于最近的定位祖先（即 `position` 不为 `static` 的父元素）进行定位，脱离文档流，不占据空间。
   - **固定定位 (`position: fixed`)**:
     - 元素相对于视口进行定位，脱离文档流，始终固定在指定位置。
   - **粘性定位 (`position: sticky`)**:
     - 元素在特定的滚动位置时变为固定定位，脱离文档流，但在其容器中仍然占据空间。

2. **使用 `float` 属性**:
   - 当元素使用 `float` 属性（如 `float: left` 或 `float: right`）时，它会脱离文档流，其他元素会围绕它进行布局。浮动元素不再占据正常的文档流位置。

3. **使用 `display` 属性**:
   - **`display: none`**:
     - 元素完全从文档流中移除，不占据空间。
   - **`display: flex` 或 `display: grid`**:
     - 这些布局模型会改变子元素的布局方式，但不会使元素脱离文档流，除非结合其他属性使用。

4. **使用 `overflow` 属性**:
   - 当设置 `overflow: hidden`、`overflow: scroll` 或 `overflow: auto` 时，可能会影响元素的布局，尤其是在处理浮动或绝对定位的子元素时。

5. **使用 `margin` 属性**:
   - **负外边距 (`margin`)**:
     - 使用负外边距可能会导致元素重叠或脱离正常的文档流，影响周围元素的布局。

- 在页面布局中，使用绝对定位、固定定位、浮动、`display: none`、负外边距等操作会导致元素脱离文档流。这些操作会影响其他元素的布局和排列，因此在使用时需要谨慎考虑其对整体布局的影响。
:::

## transform 设置成 3D 和 flex、grid 布局是否会脱离文档流？

::: details
在 CSS 中，使用 `transform` 设置为 3D 变换和使用 `flex` 或 `grid` 布局���元素的行为如下：

1. **transform 设置为 3D**:
   - 当你对一个元素应用 `transform: translate3d(...)` 或其他 3D 变换时，该元素会脱离文档流。虽然它仍然占据空间，但其位置和布局会受到变换的影响。
   - 变换后的元素不会影响其他元素的布局，其他元素会按照正常的文档流进行排列。

2. **flex 布局**:
   - 使用 `display: flex` 的元素不会脱离文档流。相反，flex 容器会影响其子元素的布局方式。
   - Flex 子元素会根据 flex 属性（如 `flex-grow`、`flex-shrink` 和 `flex-basis`）进行排列和调整，但它们仍然占据文档流中的空间。

3. **grid 布局**:
   - 使用 `display: grid` 的元素同样不会脱离文档流。Grid 容器会影响其子元素的布局，允许在网格中进行排列。
   - Grid 子元素会根据网格定义的行和列进行布局，仍然占据文档流中的空间。

- **transform 3D**: 会影响元素的视觉呈现，但不会改变其在文档流中的占位。
- **flex 布局**: 不会脱离文档流，flex 容器和其子元素会根据 flex 属性进行布局。
- **grid 布局**: 同样不会脱离文档流，grid 容器和其子元素会根据网格定义进行布局。

:::

## 浏览器为什么要有跨域限制，跨域限制的原理是什么

::: details
浏览器的跨域限制是出于安全考虑，主要是为了防止恶意网站对用户数据的访问和操作。以下是跨域限制的原因和原理：

1. 跨域限制的原因
   - **安全性**:
     - 跨域限制可以防止恶意网站通过 JavaScript 访问用户在其他网站上的敏感信息（如 cookies、localStorage、sessionStorage 等）。如果没有跨域限制，攻击者可以轻易地窃取用户的身份信息、个人数据等。

   - **防止 CSRF 攻击**:
     - 跨站请求伪造（CSRF）是一种攻击方式，攻击者诱导用户在已登录的情况下向另一个网站发送请求。跨域限制可以有效防止此类攻击，确保请求的合法性。

   - **数据隐私**:
     - 用户在不同网站之间的隐私数据需要得到保护，跨域限制确保了数据不会被未经授权的第三方访问。

2. 跨域限制的原理
   - **同源策略**:
   - 浏览器实现跨域限制的主要机制是同源策略（Same-Origin Policy）。同源策略规定，只有当两个 URL 的协议、域名和端口完全相同（即同源）时，才能共享数据和资源。
   - 例如，`http://example.com` 和 `http://example.com:8080` 是不同源的，而 `http://example.com` 和 `https://example.com` 也是不同源的。

   - **跨域资源共享（CORS）**:
   - 为了允许安全的跨域请求，浏览器引入了跨域资源共享（CORS）机制。CORS 允许服务器通过设置特定的 HTTP 头（如 `Access-Control-Allow-Origin`）来指定哪些源可以访问其资源。
   - 通过 CORS，服务器可以灵活地控制跨域请求的权限，允许特定的域名访问其资源。

   - **JSONP**:
   - 在 CORS 出现之前，JSONP（JSON with Padding）是一种常用的跨域解决方案。通过动态创建 `<script>` 标签，利用浏览器允许跨域加载脚本的特性，来实现跨域数据请求。但 JSONP 只支持 GET 请求，且存在安全隐患。

- 浏览器的跨域限制是为了保护用户数据和隐私，防止恶意攻击。通过同源策略和 CORS 机制，浏览器能够有效地控制跨域请求，确保数据的安全性和合法性。
:::
